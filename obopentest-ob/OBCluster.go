package obopentest_ob

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"io/ioutil"
	"net/http"
	"ob-open-test/k8sController"
	"ob-open-test/util"
	"strings"
	"time"

	obv1 "github.com/oceanbase/ob-operator/apis/cloud/v1"
	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/util/json"
	"k8s.io/client-go/rest"
	log "k8s.io/klog/v2"
	"sigs.k8s.io/yaml"

	_ "github.com/go-sql-driver/mysql"
)

type OBCluster struct {
	//Uid is the ns of OBCluster
	OBClusterName string //OBClusterName
	Pods          []v1.Pod
	ServerAddress        //对外服务端口
	Tag           string //多版本支持

}
type ServerAddress struct {
	Host string
	Port string
}

func (obc *OBCluster) NewOBProxy() *OBProxy {
	return &OBProxy{Ns: obc.OBClusterName}

}
func (obc *OBCluster) Ping() error {

	_, r := k8sController.NewClient()
	opts := metav1.ListOptions{}
	slist, err := r.ClientSet.CoreV1().Services(obc.OBClusterName).List(context.TODO(), opts)
	if err != nil {
		log.Warning(err)
		return err
	}

	data, _ := json.Marshal(&slist.Items)
	for _, s := range slist.Items {
		if s.Name == "svc-ob-test" {
			obc.Port = fmt.Sprint(s.Spec.Ports[0].NodePort)
			obc.Host = "127.0.0.1"
		}
	}
	plist, err := r.ClientSet.CoreV1().Pods(obc.OBClusterName).List(context.TODO(), opts)
	pods := plist.Items
	obc.Pods = pods
	data, _ = json.Marshal(&obc)
	log.Info("[obc ping] data : " + string(data))
	if !(obc.Host != "" && obc.Port != "") {
		//没有host信息，只有k8s内信息,not support
		return errors.New("not support pod type")
	}

	return nil
}

//check OBCrd is exist
func CheckAddOBCrd() bool {
	kc := k8sController.K8sClient()
	opt := metav1.ListOptions{}
	podlist, err := kc.CoreV1().Pods(util.OBoperatorNamespacs).List(context.TODO(), opt)
	if err != nil {
		log.Warning(err)
		return false
	}
	for _, pod := range podlist.Items {
		if strings.Contains(pod.Name, "ob-operator") {
			return true
		}
	}
	return false
}

//AddOBCrdByUpdate before create OBCluster
func AddOBCrdByUpdate() error {
	if CheckAddOBCrd() {
		log.Info("OBCrd is exist. need not retry。")
		return nil
	}
	clusConf, err := rest.InClusterConfig()
	if err != nil {
		log.Warning(err)
		return err
	}
	if err = k8sController.ApplyPath(clusConf, util.OBcrdPath); err != nil {
		log.Warning(err)
		return err
	}
	if err = k8sController.ApplyPath(clusConf, util.OBOperatorPath); err != nil {
		log.Warning(err)
		return err
	}
	//apply obcluster

	return nil
}
func (c *OBCluster) ApplyOBCluster() error {
	clusConf, err := rest.InClusterConfig()
	if err != nil {
		log.Warning(err)
		return err
	}

	if err = k8sController.ApplyPath(clusConf, util.OBClusterPath); err != nil {
		log.Warning(err)
		return err
	}

	return nil
}

func (c *OBCluster) ApplyOBProxy() error {
	clusConf, err := rest.InClusterConfig()
	if err != nil {
		log.Warning(err)
		return err
	}

	//obproxyPath

	if err = k8sController.ApplyPath(clusConf, util.OBProxyServicePath); err != nil {
		log.Warning(err)
		return err
	}
	//prometheus
	//if err = k8sController.ApplyPath(clusConf, prometheusPath); err != nil {
	//	log.Warning(err)
	return err
	//}

	return nil
}

func (c *OBCluster) State() string {
	kc := k8sController.K8sClient()
	opts := metav1.ListOptions{}
	serviceList, err := kc.CoreV1().Services(c.OBClusterName).List(context.TODO(), opts)
	if err != nil {
		log.Warning(err)
		return util.OBClusterStateUnready
	}
	if len(serviceList.Items) == 0 {
		return util.OBClusterStateUnready
	}
	for _, service := range serviceList.Items {
		if service.GetName() == util.OBClusterServiceName {
			return util.OBClusterStateReady
		}
	}
	return util.OBClusterStateSysErr

}

func AllOBServerTag() []string {

	url := util.GetOBServerTagURL
	method := "GET"
	payload := strings.NewReader(``)
	client := &http.Client{}
	req, err := http.NewRequest(method, url, payload)
	if err != nil {
		log.Warning(err)
		return nil
	}
	req.Header.Add("Content-Type", "application/json")
	res, err := client.Do(req)
	if err != nil {
		log.Warning(err)
		return nil
	}
	defer res.Body.Close()
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
		log.Warning(err)
		return nil
	}
	results := OBServerTO{}
	if err = json.Unmarshal(body, &results); err != nil {
		log.Warning(err)
		return nil
	}
	allTag := []string{}
	for _, tag := range results.Results {
		name := tag.Name
		allTag = append(allTag, name)
	}

	log.Info("tags:")
	log.Info(allTag)
	return allTag
}
func TagExist(tag string) bool {
	if tag == "" {
		return false
	}
	for _, taged := range AllOBServerTag() {
		if tag == taged {
			return true
		}
	}
	return false
}

type OBServerTO struct {
	Results []struct {
		Name string `json:"name"`
	} `json:"results"`
}

func (obc *OBCluster) GetService() (*v1.ServiceList, error) {
	log.Info(obc)
	kc := k8sController.K8sClient()
	listops := metav1.ListOptions{}
	service, err := kc.CoreV1().Services(obc.OBClusterName).List(context.TODO(), listops)
	if len(service.Items) < 2 {
		log.Warning(service.Items)
		err := errors.New("len(service.Items) < 2")
		return nil, err
	}
	if service.Items[1].Spec.Ports[0].Name != "mysql" {
		err = errors.New("service.Items[1].Spec.Ports[0].Name != \"mysql\"")

		return nil, err
	}
	obc.Port = fmt.Sprint(service.Items[1].Spec.Ports[0].NodePort)
	nodes, err := kc.CoreV1().Nodes().List(context.TODO(), listops)
	if len(nodes.Items) == 0 {
		err := errors.New("len(nodes.Items) == 0")
		log.Warningln(err)
		return nil, err
	}
	obc.Host = nodes.Items[0].Status.Addresses[0].Address
	if err != nil {
		log.Warningln(err)
		return nil, err
	}

	return service, nil
}
func (obc *OBCluster) ExeSql(sqlstr string) error {
	obc.Ping()
	conn := "root:@tcp(" + obc.Host + ":" + obc.Port + ")/oceanbase"
	db, err := sql.Open("mysql", conn)
	log.Warningln(db.Ping())
	db.SetConnMaxLifetime(20 * time.Second)
	if err != nil {
		log.Fatal(err)
		return err
	}
	r, err := db.Exec(sqlstr)
	log.Info(r)
	log.Warning(err)
	return err
}

func (obc *OBCluster) CreateMinTenant() error {
	sql := "ALTER SYSTEM SET memory_limit='15G';\ndrop resource unit if  exists mysqlunit;\ncreate resource unit if not exists mysqlunit max_cpu 2, memory_size '4G';\ndrop resource POOL if  exists mysqlpool;\nCREATE RESOURCE POOL mysqlpool UNIT=\"mysqlunit\" ,UNIT_NUM=1;\nCREATE TENANT mysql RESOURCE_POOL_LIST=('mysqlpool') SET ob_tcp_invited_nodes='%' ;\n"
	obc.Ping()
	return obc.ExeSql(sql)

}

func NewOBCluster(OBClusterName string) *OBCluster {
	newOBCluster := &OBCluster{OBClusterName: "obcluster-" + OBClusterName}
	return newOBCluster
}

//Check is Confirm whether there is a corresponding basic environment for deploying the cluster
//obcrd,obopcket
func (c *OBCluster) Check() bool {
	//operator check
	pods, err := k8sController.GetPodsInfoByNS(util.OBOperatorNameBase)
	if err != nil {
		log.Warning(err)
		return false
	}
	if len(pods.Items) == 0 {
		return false
	}
	for nu := 0; nu < len(pods.Items); nu++ {
		pod := pods.Items[nu]
		if strings.Contains(pod.Name, util.OBoperatorPodName) {
			break
		}
		if nu == len(pods.Items)-1 {
			//not exist
			return false
		}
	}
	k8sController.CreateNamespace(c.OBClusterName)
	return true
}
func (c *OBCluster) Add(confmap map[string]string) error {
	clusConf, err := rest.InClusterConfig()
	if err != nil {
		log.Warning(err)
		return err
	}
	yamlFile, err := ioutil.ReadFile(util.OBClusterPath)
	if err != nil {
		log.Warning(err)
		return err
	}
	obClusterConf := &obv1.OBCluster{}
	err = yaml.Unmarshal(yamlFile, obClusterConf)

	if err != nil {
		log.Warning(err)
		return err
	}

	obClusterConf.Namespace = c.OBClusterName

	confyaml, err := yaml.Marshal(obClusterConf)
	if err != nil {
		log.Warning(err)
		return err
	}

	if err := k8sController.ApplyByYamlStr(clusConf, string(confyaml)); err != nil {
		log.Warning(err)
		return err
	}

	return nil
}

//Delete is delete the OBCluster
func (c *OBCluster) Delete() error {
	log.Info("OBCluster: " + c.OBClusterName)
	err := k8sController.DeleteNamespaces(c.OBClusterName)
	return err

}
func (c *OBCluster) ClusterInfo() (*k8sController.NameSpace, error) {
	return nil, nil

}

//suppost change namespace,tag

func (c *OBCluster) Apply() error {
	_, kc := k8sController.NewClient()

	//是否已有
	if c.OBClusterName == "" {
		err := errors.New("OBClusterName is nil")
		log.Warningln(err)
		return err
	}

	if k8sController.NamespaceExist(c.OBClusterName) {
		err := errors.New(c.OBClusterName + " is exist!")
		log.Warningln(err.Error())
		return err
	}
	//OBClusterName must not exist
	if err := k8sController.CreateNamespace(c.OBClusterName); err != nil {
		log.Warningln(err.Error())
		return err
	}

	defaultOBcluster := k8sController.GetObjFromYaml(util.OBClusterYamlPath)
	defaultOBcluster.SetNamespace(c.OBClusterName)
	if !TagExist(c.Tag) {
		c.Tag = AllOBServerTag()[0]
	}

	err := unstructured.SetNestedField(defaultOBcluster.Object, c.Tag, "spec", "tag")
	if err != nil {
		log.Warning(err)
		return err
	}
	str, err := json.Marshal(&defaultOBcluster)
	if err != nil {
		log.Warning(err)
		return err
	}
	log.Info(string(str))
	err = kc.CreateObj(defaultOBcluster)
	if err != nil {
		log.Warning(err)
		return err
	}
	return nil

}

func (c *OBCluster) WaitReady() error {
	kc := k8sController.K8sClient()
	opts := metav1.ListOptions{}
	podList, err := kc.CoreV1().Pods(c.OBClusterName).List(context.TODO(), opts)
	if err != nil {

		log.Warning(err)
		return err
	}
	for _, pod := range podList.Items {
		//单机监测
		if !k8sController.WaitPodBeRunning(c.OBClusterName, pod.Name, 3*time.Minute) {
			err = errors.New(c.OBClusterName + "'s pods is not ready!")
			log.Warning(err)
			return err
		}
	}
	return nil

}
