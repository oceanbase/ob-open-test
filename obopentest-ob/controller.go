package obopentest_ob

import (
	"errors"
	"net/http"
	"ob-open-test/obopentest-web/model"

	"github.com/gin-gonic/gin"
	"k8s.io/apimachinery/pkg/util/json"
	log "k8s.io/klog/v2"
)

type OBOperatorController struct {
}

//增加OB集群
func (wc *OBOperatorController) Add(r *gin.Context) {

	data := model.AddCluster{}
	if err := r.BindJSON(&data); err != nil {
		r.JSON(http.StatusBadRequest, model.NewHttpInputErrorReply(err))
		log.Warning(err)
		return
	}
	if data.Name == "" {
		r.JSON(http.StatusBadRequest, model.NewHttpInputErrorReply(errors.New("name can't nil")))
		log.Warning("name is nil")
		return
	}
	obc := OBCluster{OBClusterName: "obcluster-" + data.Name, Tag: data.Version}
	if err := obc.Apply(); err != nil {
		r.JSON(http.StatusInternalServerError, model.NewHttpInputErrorReply(err))
		return
	}
	r.JSON(http.StatusOK, model.NewHttpSuccessReply("Add "+data.Name+" success.Please wait two minutes!"))

}

//查询现有OB集群
func (wc *OBOperatorController) Get(r *gin.Context) {
	data := struct {
		Name string ` json:"name"`
	}{}
	if err := r.BindJSON(&data); err != nil {
		r.JSON(http.StatusBadRequest, model.NewHttpInputErrorReply(err))
		log.Warning(err)
		return
	}
	if data.Name == "" {
		r.JSON(http.StatusOK, model.NewHttpSuccessReply("no inport name"))
		return
	}
	obc := NewOBCluster(data.Name)
	//get cluster port(host is k8s node ip)
	ob, err := obc.GetService()
	if err != nil || ob == nil {
		r.JSON(http.StatusInternalServerError, model.NewHttpSuccessReply(err))
		return
	}
	if len(ob.Items) == 0 {
		r.JSON(http.StatusOK, model.NewHttpSuccessReply("service is not ready or OBCluster is not exist"))
		return
	}

	c := *ob
	if c.Items[1].Spec.Ports[0].Name != "mysql" {
		r.JSON(http.StatusOK, model.NewHttpSuccessReply("service is not ready or OBCluster is not exist"))
		return
	}
	res, err := json.Marshal(obc)
	if err != nil {
		r.JSON(http.StatusInternalServerError, model.NewHttpInputErrorReply(err))
		return
	}
	r.JSON(http.StatusOK, model.NewHttpSuccessReply("service is"+string(res)))

}

func (wc *OBOperatorController) Update(r *gin.Context) {
	r.JSON(http.StatusNotFound, model.NewHttpInputErrorReply(errors.New("can't Update")))
}

func (wc *OBOperatorController) Delete(r *gin.Context) {
	data := model.AddCluster{}
	if err := r.BindJSON(&data); err != nil {
		r.JSON(http.StatusBadRequest, model.NewHttpInputErrorReply(err))
		log.Warning(err)
		return
	}
	obc := OBCluster{OBClusterName: "obcluster-" + data.Name}
	if err := obc.Delete(); err != nil {
		r.JSON(http.StatusInternalServerError, model.NewHttpInputErrorReply(err))
		return
	}
	r.JSON(http.StatusOK, model.NewHttpSuccessReply("Delete "+data.Name+" success"))
}
func (wc *OBOperatorController) Version(r *gin.Context) {
	r.JSON(http.StatusOK, model.NewHttpSuccessReply(AllOBServerTag()))

	return
}

func (wc *OBOperatorController) Test(r *gin.Context) {

}
